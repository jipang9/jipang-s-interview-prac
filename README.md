# jipang-s-interview-prac

1. 배열(Array)과 링크드리스트(Linked List) 의 비교 설명

    배열과 링크드리스트는 데이터를 저장하는 자료 구조의 종류 ( 공통점 )
    배열은 선언 시 배열 길이를 선언하기에, 고정된 크기를 갖는다, 링크드리스트는 유동적인 크기 ( 차이점 )
    배열은 메모리 속 연속된 형태로 저장되어있다. 그래서 중간 데이터를 삭제할 때, 해당 공간의 메모리가 낭비된다는 장점 -> 이를 해결하려면 shift와 같은 추가적인 작업 필요 
    링크드리스트는 포인터라는 개념을 통해 서로 연결되어있는 형태로 저장되어있음. 그래서 중간 데이터가 삭제 되더라도, 노드 간 포인터를 이용해 연결만 해주면 됨

    접근적 측면에서 바라보면 특정 요소에 접근할 때, 배열의 인덱스를 알 경우 O(1)의 시간 복잡도를 갖지만, 인덱스를 모른다면 O(N)의 시간 복잡도 (Random Access)
                                                링크드리스트는 항상 순차적으로 접근을 해야한다 그래서 O(N) (Sequential Access)

    사용적인 측면에서 바라보면 배열은 링크드리스트에 비애 접근이 용이하기에 데이터의 접근과 관련된 작업을 진행하는 부분에서 이점이 있다.
                             링크드리스트는 배열에 비해 삭제와 삽입과 같은 행위들에 이점이 있어서 이와 같은 작업을 진행하는 부분에 이점이 있다.


2. CORS란 무엇이고 어떻게 허용할 수 있나요?
  
   교차 출처 리소스 공유(Cross - Origin - Resource Sharing)이라는 의미를 가진 CORS는 추가 HTTP헤더를 사용해서 한 출처에 실행중인 웹 애플리케이셔닝 다른 출처의
   선택한 자원에서 접근    할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제입니다. 
   이를 스프링 내부에서 허용하는 방법은 3가지가 있는데, 
   첫번째로 서블릿 필터(Servlet Filter)를 사용해 커스텀한 CORS를 설정하는 방법, 
   두 번째 방법은 WebMvcConfigure를 구현한 Configuration 클래스를 만들어서 addCorsMappings()를 재정의 해서 해결할 수 있습니다. 
   마지막으로 스프링 시큐리티(Spring Security)에서 CorsCOnfigurationSource를 이용해 Bean으로 등록하고 config에 추가하면 허용이 가능합니다.
   
3. 시간 복잡도와 공간 복잡도가 무엇인지 설명하시오

    시간 복잡도는 특정 문제를 해결하는데 걸리는 시간을 의미 하는데, 연산의 횟수를 세고 처리해야 할 데이터의 수 n에 대한 연산 횟수의 함수 T(n)을 만들어서 계산한다. 
    공간 복잡도는  특정 문제를 해결하는데 얼마나 많은 메모리를 사용하는 지 분석하는 방법이다.
    
4. 사용자 패스워드를 전송하고 보관하는 방법을 설명하시오
    
    내가 생각한 패스워드 보관 방법은 2가지이다. 평문 그대로 저장하거나, 암호화를 적용해서 저장하거나, 평문 그대로 저장하게 된다면 탈취 당할 위험이 매우 높다.
    그래서 일반적으로 후자인 암호화를 적용해서 저장하게 되는데 여러 암호화 방식 중 단방향 해쉬 함수를 사용해서 암호화를 진행한다. 
    입력 받은 평문을 여러 알고리즘을 통해 암호화 하게 되고, 이를 저장하는 방식인데 이 방식 역시 안전하지 못한 단점이 있다. 
    동일한 메시지는 동일한 다이제스트를 얻게 되는데,  다이제스트를 모아 리스트 형태로 만든 것을 레인보우 테이블이라고 한다. 
    그래서 이 테이블에서 패스워드를 유추할 수 있다. 또 무차별 대입 공격(부르트포스)에 노출되어 있는데 시간만 있으면  하나 하나 대입을 통해 찾을 수 있다. 
    그래서 보완하기 위해 키 스트레칭 방식과 솔트 방식을 이용해 암호화의 보안성을 높일 수 있다.
    
5. 스택, 큐에 대해 설명해주실 수 있을까요?

    스택과 큐는 선형 자료구조의 종류입니다. 그러나 자료를 담고, 빼내는 부분에 있어서 명확한 차이를 보입니다. 우선 스택 경우엔 LIFO인 후입선출의 구조를 갖고 있습니다. 
    그래서 가장 최근에 들어온 데이터가 가장 먼저 나가게 되며 주로 출력 순서가 입력 순서의 역순으로 이루어져 있는 영역에서 주로 사용합니다.
    큐는 스택과 다르게 FIFO인 선입선출의 구조를 갖고 있습니다. 
    이는 가장 먼저 들어간 데이터가 가장 먼저 나간다는 의미를 갖는데 순차적인 작업이나 실행/사용하기 위해 대기 시킬 때 주로 사용합니다.
    
6.  DI와 IoC에 대해 아는 만큼 설명해주실 수 있을까요?
    
    DI는 의존성 주입 혹은 의존관계 주입이라는 의미를 갖고 있는데, 다른 프레임워크와 차별화 된 Spring의 기능입니다. 
    이는 객체를 직접 생성하는 것이 아니라 외부에서 생성한 후 주입 시키는 방식을 말하는데, Bean 정보를 바탕으로 의존관계를 컨테이너가 자동으로 연결해주는 것입니다. 
    그래서 모듈간 결합도도 낮아지고 유연성이 높아지는 장점이 있습니다. 이 의존성 주입에는 3가지 방법이 있는데 생성자 주입, Setter주입, Interface 주입이 있습니다.
    IoC는 제어의 역전이라는 뜻을 가집니다. 필드에 관한 제어권을 외부로 넘기는 것인데, 역할과 책임의 분리를 통해 객체 지향이 추구하는 원칙을 잘 지키고자 IoC가 필요합니다. 
    이를 통해서 응집도는 높이고 결합도는 낮추며 변경에 유연한 코드가 작성가능하기 때문입니다
    
    
7. hibernate란?

    하이버 네이트는 자바(Java)를 위한 ORM 프레임워크 입니다. 이 하이버 네이트는 JPA의 구현체로 JPA 인터페이스를 구현하며 내부적으로 JDBC API를 사용합니다. 

    hibernate의 장점은 다음과 같습니다.

    - 생산성
        - SQL문을 직접 사용하지 않고, 메서드 호출을 이용한 쿼리문 수행, 이로 인해서 개발자의 생산성이 향상됩니다 ( 왜? 직접 쿼리를 짜지않아도 되니까 )
    - 유지보수
        - 컬럼이 변경되거나 관련 작업에 관한 SQL의 수행을 대신 해줍니다. 그래서 유지보수가 쉬워집니다.
    - 특정 벤더에 종속적이지 않는다 ( 특정 DB에 종속적이지 않다는 말 )
    - JPA는 추상화된 데이터 접근 계층을 제공해서 특정 벤더에 종속적이지 않습니다.
    - 설정파일에 DB만 알려주면 사용가능 하다는 점.
    - 이로인해 재사용성이 늘어났다.
    - 패러다임 불일치
        - 객체와 RDB 사이의 패러다임 불일치를 해결할 수 있습니다.

   hibernate의 단점은 다음과 같습니다.

    - DB를 설계할 수 있는 능력이 필요함
    - 복잡한 쿼리나 통계에 필요한 쿼리는 Native SQL로 작성해야하는 경우가 생김 ( 메서드 호출만으로 완벽하게 데이터를 가지고오지 못함, 그래서 JPQL 지원 및 NativeQuery 지원)
    - 메서드 호출을 통해 SQL을 사용해서 직접 SQL을 작성하는 것보다 성능상으로 좋지 못함

    일단 하이버 네이트를 사용할 경우 객체에 비즈니스 책임을 위임할 수 있습니다.
    객체를 불러올 때 연관된 객체를 같이 들고와서 SQL에 의존적이지 않은 개발이 가능하다. 이말은 SQL 중심이 아닌 객체 중심의 개발이 가능하다.
    
8. call by reference란 무엇이고 보통 어떻게 쓰이나요?

    Call by reference는 참조에 의한 호출을 말합니다. 함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 만들어 지는데, 
    이 공간은 함수가 종료되면 사라집니다. 
    함수를 호출 할 때 인자로 전달되는 변수의 레퍼런스를 전달하는데 함수 안에서 인자 값이 변경되면 argument로 전달된 객체의 값도 변경됩니다. 
    자바에서는 새롭게 지역 변수를 만들어서 값만 복사하고 할당하기에 Call by value 즉 값에 의한 참조를 기본으로 하고있습니다.

9. Override & Overroad

    override는 상위 클래스의 기능을 하위 클래스에서 재정의해서 사용하는 것을 말하고, Overroad는 이름이 같은 메서드를 매개변수의 값이나 개수, 타입이 다른 메서드는 다른 메서     드임을 의미합니다. 
    
10.  MVC 모델이란 무엇인가요?

    MVC 모델은 3개의 관심사 아키텍쳐(모델, 뷰, 컨트롤러)로 나눠서 분리하는 모델입니다. 이렇게 관심사를 분리함으로써 각 관심사에만 집중할 수 있는 장점이 있습니다. 
    비즈니스 로직과 UI 로직을 분리해서 유지보수를 더욱 쉽고 독립적으로 수행 가능한 장점이 있습니다. 이로인해 확장성과 유연성에 유리합니다.

    그러나 서비스의 규모가 커지고 view나 model이 늘어남에 따라 하나의 컨트롤러에 여러 개의 복잡한 뷰가 연결되면 복잡도가 증가하고 오류 발생 가능성이 높아질텐데, 
    이 대안책으로 MVVM 모델이 있습니다. 
    
11. JPA는 언제 필요하고, 언제 필요하지 않은지
    
    JPA는 특정 DB에 종속되지 않고, 성능상의 이점을 얻을 수 있습니다. 또한 메소드 호출만으로 쿼리를 실행할 수 있어서 개발자의 생산성과 유지보수가 쉬워집니다. JPA를 사용하면     SQL 중심의 개발에서 객체중심의 개발이 가능합니다. 그러나 복잡한 쿼리나 여러 객체들이 연관관계를 맺고 있으면, Entity를 잘못 설계하게되면 불필요한 데이터를 탐색하거나 
    쿼리문이 발생할 염려가 생기는데, 그래서 성능에 이슈가 발생할 가능성이 있습니다. 그래서 JPA는 복잡한 쿼리보다는 실시간 쿼리에 최적화 되어있으며, 복잡한 쿼리는 SQL을 직접     작성 하는 편이 좋습니다. 
    
12. JPA의 더티 체킹이란 무엇인가요?
    
    더티체킹은 JPA의 특징 중 하나입니다. JPA에서는 트랜잭션이 끝나는 시점에서 변화가 있는 엔티티 객체를 대신에 DB에 자동으로 반영해줍니다. 이를 더티 체킹이라고 합니다.
    JPA가 엔티티를 조회하면 최초의 상태인 스냅샷을 영속성 컨텍스트의 관리 대상으로 올립니다. 트랜잭션이 닫히는 시점에 해당 엔티티에 변화가 있다면 스냅샷과 비교 후 자동으로 
    데이터베이스에 update query를 전달합니다. 더티 체킹을 사용하기    위해선 객체가 영속성 컨텍스트의 관리 대상이 되어야 합니다. 

13. Annotation이란 무엇이고 구체적으로 어떤 것이 있는지 예시를 들어 설명해주실 수 있을까요?
    
    어노테이션이라는 개념은 사전적 의미는 주석이라는 의미를 갖는데, 코드에 추가해서 사용할 수 있는 메타 데이터의 일종입니다. 
    이미 라이브러리나, 내부에 종속되어 있으며 사용자는 이 어노테이션을 만들어서 사용 가능합니다. 
    어노테이션을 사용하게 되면 개발 시 추가적인 코드를 생성해주거나 개발에 많은 이점을 얻을 수 있습니다. 
    그리고 런타임 시 특정 기능을 실행하도록 정보를 제공하는 이점이 있습니다.
    대표적으로 java에서 많이 사용하는 @override 를 예시로 들자면 상위 클래스의 기능을 재정의 할 때 많이 사용합니다. 
    그래서 하위 클래스에서 재정의 하고자 하는 메소드에 어노테이션을 붙이게 되면 사용할 수있으며, 
    만약에 상위 클래스에서 정의하고 있는 메소드를 하위 클래스에서 정의하지 않는다면 컴파일 오류가 발생합니다.
    
14. 인덱스란 무엇이고 일반적인 원리는 어떠한지 설명해주실 수 있을까요?

    인덱스는 데이터를 빠르게 찾기 위해 사용하는 자료구조의 종류입니다. 인덱스는 키-값 형태로 데이터를 저장하며, 인덱스를 만들고자 하는 컬럼의 데이터를 정렬한 후 별도의 
    메모리 공간을 할당해서 데이터의 물리적 주소와 함께 저장합니다. 인덱스는 이 물리적 주소를 이용해 데이터를 빠르게 검색 할 수 있습니다. 
    인덱스가 생성되었으면 생성한 인덱스의 컬럼을 where 조건으로 질의하면 옵티마이저에서 판단하여 생성된 인덱스를 타게 됩니다. 그러면 인덱스에 저장되어있는 데이터의
    물리적 주소로 가서 데이터를 가지고 오게 됩니다. 
    
15. 이분탐색이 무엇이고 시간복잡도는 어떻게 되며 그 이유는 무엇인가요?

    이분탐색의 영명은 Binary Search입니다.  이 알고리즘의 전제 조건은 정렬되어있는 리스트의 탐색입니다. 주어진 데이터의 탐색 범위를 절반씩 좁혀가며 찾고자 하는 데이터를 
    탐색하는 방법입니다. 주어진 배열의 중간 인덱스의 element값과 찾고자 하는 값을 비교해서 중간 인덱스 기준으로 좌 우측으로 방향을 정하며, 이렇게 반복 수행을 통해 원하는
    데이터를 찾습니다.  단계마다 범위를 반으로 나누는 행위와 동일하므로 O(logN)의 시간 복잡도를 갖습니다. 식을 정의해보자면 N개의 데이터를 횟수별로 1/2를 하기에 k번째 
    탐색 데이터에 관한 수식을 세울 수 있습니다. 
    (1/2)^K x N 
    최악의 경우의 수는 해당 식이 1이 될 때 까지 탐색을 해야하는데, 위 식의 양변애 2^k를 곱하면 2^k = N, 다시 양변에 log2를 취하면 시간 복잡도를 구할 수 있습니다.
    
